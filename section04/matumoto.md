# 第４章 OOPは無駄を省いて整理整頓するプログラミング技術

## 第3章までの課題

エドガー・ダイクストラか提案した、構造化プログラミングで以下の課題が残った

- グローバル変数
- 貧弱な再利用

## OOPの三大要素

- クラス
- ポリモーフィズム
- 継承

### クラス

機能をまとめて、機能をかくして、インスタンスをたくさん作る

- まとめる
  - クラスとして作っておくと、意味論としてきれいになるというのはありそう
  - まとめることで、再利用性があがっている
- かくす
  - インスタンス変数を隠すことでグローバル変数どうしよう問題を解決している
- インスタンスをたくさん作る
  - 強力な再利用性

### ポリモーフィズム

- 呼び出す側の統一化
  - インターフェースとかを継承して、それを使うことで呼び出す側はロジックを気にせず呼び出せるよね

ポリモーフィズムの正しい活用こそがOOPのパワーだなんて言う意見もあったりする(依存性逆転の法則)

<details> <summary> 依存性逆転の法則自分用メモ(今回のやつとは関係ない) </summary>

- ふつうは上位レベルの関数が下位レベルの関数を呼び出すので、上位→下位に依存
- しかし上位レベルの関数がインターフェース経由で呼び出すと、下位レベルの関数→インターフェースの方向に依存の方向が変わり、依存性が逆転する！

  **下位**

  ```cpp
  class DBInterface {
    virtual int hoge();
  };

  class DB: public DBInterface {
    DB() {}

    int hoge() {
      // hogeeeeeeeeeeeeeeeeeeeeeeee
      // 本当は処理内容を分けたいが...
    }
  };
  ```

  **上位**

  ```cpp
  #include "./DBInterface.hpp"

  int main() {
    DB db;
    db.hoge();
  }
  ```

</details>

### 継承

- クラスを継承するとコードの重複がなくせる
  - ただ、最近は具象クラスを継承せずに、抽象クラスだけ継承しましょうみたいなのをよく聞く

## 型

型でチェックすることによって楽できるよね  
クラスを型として使える

静的型付け言語と動的型付け言語がある

## プログラミング言語の変遷

使えない機能を削っていっていたり、欠点をおぎなったりして進化をしている

- 構造化プログラミングによって「直接的な制御の移行」に規律が課せられた
- オブジェクト指向プログラミングによって、「間接的な制御の移行」に規律が課せられた
- 関数型プログラミングによって、「代入」に規律が課せられた

## さらに進化したOOPの仕組み

- パッケージ
  - いわゆる名前空間のようなもの
- 例外
  - エラーがあることだけ明記し、エラーを返す。実際に処理を行うのは返ってきた一番上
- ガベージコレクション
  - スコープ内で宣言されたローカル変数のメモリとかがスコープを抜けると開放されるなど

## OOPの進化

OOPでは生産性の向上のための進化はしていない

保守性、品質、再利用促進といった保守性向上の仕組みが大幅に強化された

## OOPの使いみち

COBOL/C言語でもOOPはできる(むしろ完全なOOPはC言語が持っていて、C++とJavaでは不完全という意見もある)

機能というよりそういう考え方であり、手段であって、目的であるコード品質の向上が最も大事
