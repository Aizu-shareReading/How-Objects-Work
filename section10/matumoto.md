# 第10章 擬人化して役割分担させるオブジェクト指向設計

## 背景

<!--
たぶん、言っても言わなくても同じなので、情報を限定するために省略
### 設計が対称とする範囲は広く深い

設計作業の具体的な内容やノウハウは作成するアプリケーションによって全く異なるので広すぎる
-->

### 実行効率よりも保守性や再利用性が重視される時代

もともとは、実行効率（メモリ計算量、時間計算量）が重視されていた  
しかし、最近のマシンパワーによってそれが解決され保守性や再利用性が重視されるようになった

OOPの仕組みやデザインパターンなどをどう利用するかが重要

## 設計

### 設計の目標1 重複を排除する

- 同じコードがある場合はクラスや関数にしてまとめる方が修正もしやすい
- ジェネリクスなどを使用して汎用性が高められるところは高めたい
  - 過度な抽象化には注意

### 設計の目標2 部品の独立性を高める

凝集度と結合度

#### 凝集度とは?

部品のまとまり具合を指し示す指標  
例. `Filer` クラスに `open` メソッドや `read` メソッドとかはあっていいけど、`findString`メソッドのようなものは必要ないよね

ちなみに、7段階のレベルに分類することができる  
[わかりやすい記事](https://www.affordd.jp/koha_hp/KeyWords/KW.Coupling.html)

これはおそらくSOLID原則のうちのSingleResponsiblityPrinciple(単一責任の原則)につながっている

#### 結合度とは?

部品間の結びつき度合いを指し示す指標  
例. DBにデータを入れるときに、仮にDBがMySQLからPostgreSQLに変更しても動けるようにする

これもおそらくSOLID原則のうちのSingleResponsiblityPrinciple(単一責任の原則)につながっている

### 設計の目標3 依存関係を循環させない

依存関係の循環があると、なにか一つを変更したらそれに依存しているまとまり全てを変更する必要が出てきてしまう

ちなみに、依存関係をグラフに落とし込んだとして、循環を見つけるには強連結成分分解をすればよい

これはおそらくSOLID原則のうちのDependencyInversionPrinciple(依存関係逆転の法則)につながっている

### オブジェクト指向設計の感覚は擬人化と役割分担

擬人化っていうのは、Goとかだと構造体の名前とかに「〇〇er」みたいにするのが感覚的に近そう  
例. Filer, Fetcher

役割分担は責任を明確にしようみたいな話？

### 役割分担されたソフトウェアが作る奇妙な世界

おもしろいね
