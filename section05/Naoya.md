# OOPにおけるメモリの仕組み
## プログラム実行方式

- コンパイラ方式
    - プログラムを機械語に変換した後に、実行する
  - メリット
    - 実行速度が速い
  - デメリット
    - 実行までに時間がかかる
    - 環境に依存するので、異なるプラットフォームで実行できない。（その環境でコンパイルする必要がある）
- インタプリタ方式
  - プログラムの命令を逐次解釈して実行する
  - メリット
    - プログラムをすぐに実行できる
    - 異なるプラットフォーム（マシン, OS）で互換性を保てる
  - デメリット
    - 実行速度の遅さ
- 中間コード方式
  - コンパイラを使って、ソースコードを特定の機械語に依存しない中間コードに変換し、その中間コードを専用のインタプリタによって解釈して実行する
  - 例）java,　C#
  - 仮想マシン(Virtual Machine)
    - 中間コードを解釈して動作する仕組み 
    - プラットフォームごとに提供されている
## CPUの動き
- マルチスレッド環境 → スレッドを複数同時に実行できる環境
  - CPUが複数のスレッドの処理を１つずつ少しずつ順繰りに実行
## メモリ領域
- 静的領域
  - プログラムの開始時に確保され、プログラムの終了時まで配置が固定されている領域
  - 格納される情報
    - 静的な変数
      - グローバル変数
    - コード情報
  - アプリケーションでまとめて１つ
- ヒープ領域
  -　プログラムの実行時に動的に確保するためのメモリ領域
  -　プログラムの実行中にアプリケーションから必要なサイズを要求することで割り当てを行い、不要になれば元に戻す。
  -　格納される情報
    -　任意 
  - システムorアプリケーションで1つ
- スタック領域
  - スレッドの制御のために使うメモリ領域
  - LIFOで領域を確保
  - 格納される情報
    - 呼び出したサブルーチン(OOPではメソッド)
    - ローカル変数
    - 戻り先
  - スレッドごとに1つ
- クラス情報
  - クラス情報をメモリにロードする2つの方式
    - 事前に全てのクラス情報を一括してロードする方式
    - 必要な時点で逐次ロードする方式
      - 新しいクラスを読み込むたびにオーバーヘッドがかかる
        - 実行性能が落ちる
        - 動くコード分だけメモリを使うので、全体のメモリ使用量を減らせる
        - ネットワーク越しに分散して管理しているプログラムファイルを実行時に結合して動かすことが容易になる
        - 実行時の柔軟性も確保できる
      - クラス情報→メソッドエリア（静的領域）に配置
      - クラスのインスタンス変数→ヒープ領域に配置
        - インスタンスからメソッドエリアにあるクラス情報への対応づけを行う
        - インスタンスを格納する変数には、"インスタンスのポインタ"を格納する
      - メソッドの引数やローカル変数 → スタック
  - メソッドテーブル
    - 各クラスに用意される
    - メソッドのポインタを順番に格納したもの
  - 継承
    - メソッドテーブルに継承されたメソッドも含めて定義する
    - 実際のコード情報は親クラスのメソッドエリアの情報を参照して使い回す
    - インスタンス変数は、ヒープ領域に造られるサブクラスの全てのインスタンスにコピーして保持される
- ガベージコレクション
  - ヒープ領域に残った不要なインスタンスを自動的に削除する仕組み
    - 不要なインスタンス→孤立したインスタンス
      - スタックとメソッドエリアから辿れないインスタンス
  - ガベージコレクタ
    - プログラミング言語の実行環境(Vertual Machine)が提供する、独立したスレッドの動作
    - 空きメモリ領域が少なくなったとき、ガベージコレクション処理を起動

## 単語リスト
- スレッド → プログラムの実行単位
- プロセス　→ コンピュータの中で動くひとまとまりの実行単位





