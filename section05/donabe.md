# メモリの仕組みの理解はプログラマのたしなみ

### コンパイラ方式
ソースコードを事前に機械語

### インタプリタ方式
実行時にソースコードを読みながら動く  
実行環境に依存しない

### 中間コード方式
上記2つのいいとこ取り  
実行環境ごとに仮想マシンがある  
ソースコード→中間コード→機械語

## メモリ領域

### 静的領域
アプリケーション開始時に確保する  
グローバル領域、実行コード

### ヒープ領域
開始時に一定領域確保し、必要都度に切り分ける

### スタック領域
サブルーチンの引数、ローカル変数、戻り先  
スレッドに1つ

## クラスのロード
メソッド情報は1クラスに1つだけロードする
### 事前に全てを一括ロード
C++

### 逐次ロードする
Javaや.NET

静的エリアではなくメソッドエリアと呼ぶ

## インスタンスの生成
インスタンス生成のたびにヒープ領域が使われる

クラスは1つでインスタンスはその場所を指し示す  
OOPで書いたプログラムは有限のメモリ領域であるヒープ領域を大量に使って動く

### 変数にはインスタンスのポインタが格納される
変数にはヒープ領域にあるインスタンスのポインタが格納される

## ポリモーフィズムは異なるクラスが同じ顔を見せる
### メソッドテーブル
メソッドのポインタを格納したもので異なるクラスが同じ顔を見せるための仕掛け

メソッドテーブルの形式がスーパークラスと同じになっている→同じ方法でメソッドを呼び出すことができる

## メモリ配置
### メソッド
スーパークラスに定義したメソッドはサブクラスでも利用できる  
継承されたメソッドのコード情報はサブクラスではメモリに展開せずスーパークラスの情報を利用する

継承されたメソッドをメソッドテーブルに格納するものの、実際のコード情報はスーパークラスのものを使い回す

### インスタンス変数
インスタンス変数の定義はコピーされるが、値はインスタンスごとに違う  
スーパークラスで定義されたインスタンス変数は、ヒープ領域に作られるサブクラスのすべてのインスタンスにコピーされ保持される

## ガベージコレクタが処分するもの
孤立したインスタンスを処分する

ヒープ領域にあるインスタンスにスタック領域やメソッドエリアからたどれるか否か  
孤立したら処分する


