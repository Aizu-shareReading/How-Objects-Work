# 第五章 メモリの仕組みの理解はプログラマのたしなみ



## プログラムの実行方式



- コンパイル方式：C/C++など

  - メリット
    - はやぁぁぁぁぁいッッ！！！説明不要ッ！

  - デメリット
    - コンパイル後の実行ファイルを異なる実行環境間で受け渡ししても使えない

- インタプリタ方式：Pythonなど

  - メリット
    - 環境に合わせて翻訳するので、コードを変える必要がない
  - デメリット
    - 逐次翻訳するので遅い

- 中間コード方式：Javaなど

  - メリット
    - インタプリタ方式よりは早い
    - 実行環境の違いを仮想マシンが吸収してくれる
  - デメリット
    - コンパイル方式よりは遅い
    - コンパイル→仮想マシンで実行の手間がある（これは無視できるレベル）



## スレッドとプロセス



### 単位の大きさ

- スレッド＜プロセス

- スレッド＝タスク

- プロセス＝ジョブ



プロセスの中にスレッドが複数あってもいい

例：VSCodeの中でファイルシステムと言語の補完機能がある、みたいな



### CPUの動き方

ここでね、ラウンドロビン方式やらなんやらの伏線回収ってわけね

:arrow_down: タスクスケジューリング方式一覧

| 名前                 | 説明                                                         |
| -------------------- | ------------------------------------------------------------ |
| 到着順方式           | 実行可能状態になった順番に処理する方式                       |
| 優先度順方式         | タスクに優先度を設定し、優先度順に処理する方式               |
| 動的優先度順方式     | 基本は優先度順方式と同じだが、待ち時間の長さに応じて優先度を徐々に上げていく方式 |
| ラウンドロビン方式   | CPUを使用する時間を定め、その時間内に処理が終わらない場合は、次のタスクに使用権が与えられる方式 |
| 多重待ち行列方式     | ラウンドロビン方式に優先順位を加味させた方式                 |
| 処理時間順方式       | タスクの処理時間が短いものから処理する方式                   |
| イベントドリブン方式 | マウス操作によるイベントでCPUの使用権を切り替える方式        |



## 3つのメモリ領域



- 静的領域
  - プログラムの開始から終了まで確保され続けるメモリ領域
  - グローバル変数や、クラスのコード情報など
- ヒープ領域
  - 実行時に確保されるメモリ領域（基本的に他の領域はコンパイル時などに確保される）
  - Cだと `malloc`、C++だと `new` とか `std::vector::push_back`など
- スタック領域
  - ローカル変数とか、再帰呼出しの呼び出し元とかが入る
  - コンピュータアーキテクチャ論でスタックポインタとかで呼び出し元、管理しましたねぇ
  - 再帰呼出しがスタックを使って実装されていることから、再帰で表現されていることはすべてスタックとループを使用して書き表せることが分かる





## ポリモーフィズムの内部実装



- メソッドテーブルがある
  - メソッドテーブルは各メソッドへの関数ポインタを保持しているテーブル（図を見たほうが早い）
  - これによって、継承の際のメソッドの実装とかができる
    - 例、継承したメソッドをオーバーライドしたら関数ポインタの示す先を変えるだけで良い（オーバーライドしなかったらそのまま親のを指す）
    - あと、Javaとかの `super.Aiueo()` みたいに親のを指す用のメソッドテーブルもしれっと用意されていそう



## ガベージコレクタ



- 不要なインスタンスのメモリを削除する
  - ヒープ領域の中で孤立しているものなど
    - 例、スコープを抜けたローカル変数
  - 静的領域、スタック領域にあるインスタンスは削除されない
    - 例、クラスごとの静的変数、再帰呼出し中の引数







